# ai_coding_agent/code_executor/runner.py
import json
import sys
import traceback

# This script runs INSIDE the Docker container.
# It expects two files to be present:
# 1. 'generated_code.py': Contains the function generated by the AI.
# 2. 'test_cases.json': Contains the test inputs and expected outputs.

def execute_code_and_test():
    results = []
    code_output = ""
    error_message = None
    exception_type = None

    try:
        # Dynamically load the generated function
        # The AI-generated code must define a function named 'solve'
        # For simplicity, we assume 'generated_code.py' defines a 'solve' function.
        # In a real scenario, you'd parse the generated code to find the function name.
        sys.path.append('.') # Add current directory to path for import
        import generated_code
        solution_function = generated_code.solve

        # Load test cases
        with open('test_cases.json', 'r') as f:
            test_cases = json.load(f)

        for i, test_case in enumerate(test_cases):
            test_input = test_case.get('input')
            expected_output = test_case.get('expected_output')
            actual_output = None
            test_passed = False
            test_error = None

            try:
                # Call the AI-generated function
                # Ensure test_input is unpacked if it's a list for multiple arguments
                if isinstance(test_input, list):
                    actual_output = solution_function(*test_input)
                else:
                    actual_output = solution_function(test_input)

                test_passed = (actual_output == expected_output)

            except Exception as e:
                test_error = f"Test Case Exception: {type(e).__name__}: {str(e)}"
                exception_type = type(e).__name__
                # Capture traceback for more detailed debugging later if needed
                # test_error += "\n" + traceback.format_exc()

            results.append({
                "test_number": i + 1,
                "input": test_input,
                "expected_output": expected_output,
                "actual_output": actual_output,
                "passed": test_passed,
                "error": test_error
            })

        code_output = "All tests processed."

    except ImportError as e:
        error_message = f"Code loading error: Could not import 'generated_code.py' or 'solve' function not found. Error: {str(e)}"
        exception_type = "ImportError"
    except FileNotFoundError as e:
        error_message = f"File not found error: {str(e)}"
        exception_type = "FileNotFoundError"
    except Exception as e:
        error_message = f"Runtime error in runner: {type(e).__name__}: {str(e)}"
        exception_type = type(e).__name__
        # For general exceptions in the runner itself, include a traceback
        error_message += f"\n{traceback.format_exc()}"


    final_report = {
        "success": error_message is None and all(r['passed'] for r in results if r['passed'] is not None),
        "output": code_output,
        "error_message": error_message,
        "exception_type": exception_type, # Type of major error encountered (e.g., ImportError, NameError)
        "test_results": results
    }

    print(json.dumps(final_report))

if __name__ == "__main__":
    execute_code_and_test()
